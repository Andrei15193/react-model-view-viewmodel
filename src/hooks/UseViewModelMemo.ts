import type { INotifyPropertiesChanged } from '../viewModels';
import { type DependencyList, type useMemo, useRef } from 'react';
import { useViewModel } from './UseViewModel';

const emptyDeps: DependencyList = [];

/**
 * Represents a view model factory callback.
 * @template TViewModel The type of view model to create.
 */
export type ViewModelFactory<TViewModel extends INotifyPropertiesChanged | null | undefined> = () => TViewModel;

/**
 * Ensures a view models instance per component generated by the factory and watched for changes. Whenever the provided deps
 * change a new instance is created, similar to {@linkcode useMemo}.
 * @template TViewModel The type of view model to create.
 * @param viewModelFactory The view model factory callback for creating an instance.
 * @param deps Dependencies of the callback, whenever these change the callback is called again, similar to {@linkcode useMemo}.
 * @returns Returns the created view model instance.
 */
export function useViewModelMemo<TViewModel extends INotifyPropertiesChanged | undefined | null>(viewModelFactory: ViewModelFactory<TViewModel>, deps: DependencyList): TViewModel {
    const normalizedDeps = deps === null || deps === undefined || !Array.isArray(deps)
        ? emptyDeps
        : deps;

    const viewModelRef = useRef<{ readonly instance: TViewModel | null } | null>(null);
    const cachedDependencies = useRef(normalizedDeps);
    if (viewModelRef.current === null || cachedDependencies.current.length !== normalizedDeps.length || cachedDependencies.current.some((cachedDependency, dependencyIndex) => !Object.is(cachedDependency, normalizedDeps[dependencyIndex]))) {
        cachedDependencies.current = normalizedDeps.slice();
        viewModelRef.current = { instance: viewModelFactory() };
    }
    const { current: { instance: viewModel } } = viewModelRef;

    useViewModel(viewModel);

    return viewModel!;
}